# 真迹项目技术资产报告

## 1. Store 状态流转对齐

### 完整代码
```typescript
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { InputType } from '@/types';

// 定义协议数据类型
export interface ProtocolParam {
  id: string;
  name: string;
  type: string;
  defaultValue?: any;
  min?: number;
  max?: number;
  step?: number;
  required?: boolean;
  options?: Array<{ label: string; value: any }>;
}

// 定义 IO 模式类型
export type OutputType = 'image' | 'video' | 'audio' | 'text' | 'json';

// 定义 IO Schema
export interface IOSchema {
  inputType: InputType;
  outputType: OutputType;
}

// 定义资产缓冲区类型
export interface AssetBuffer {
  id: string;
  type: InputType;
  data: string | Blob | File | ArrayBuffer;
  name?: string;
  size?: number;
  duration?: number;
}

export interface ActiveProtocol {
  id?: string;
  api_endpoint: string;
  model_id: string;
  name?: string;
  provider?: string;
  endpoint?: string;
  params_schema: ProtocolParam[];
  input_params: Record<string, any>;
  io_schema: IOSchema;
  test_result?: any;
  verified?: boolean;
  isVerified?: boolean;
  assetBuffer?: AssetBuffer;
}

// 定义状态类型
interface ProtocolState {
  activeProtocol: ActiveProtocol | null;
  assetBuffer: AssetBuffer | null;
}

// 初始状态
const initialState: ProtocolState = {
  activeProtocol: null,
  assetBuffer: null
};

// 创建 Context
const ProtocolContext = createContext<{
  state: ProtocolState;
  setActiveProtocol: (protocol: ActiveProtocol | null) => void;
  updateProtocol: (updates: Partial<ActiveProtocol>) => void;
  clearProtocol: () => void;
  setAssetBuffer: (asset: AssetBuffer | null) => void;
  updateAssetBuffer: (updates: Partial<AssetBuffer>) => void;
  clearAssetBuffer: () => void;
}>({
  state: initialState,
  setActiveProtocol: () => {},
  updateProtocol: () => {},
  clearProtocol: () => {},
  setAssetBuffer: () => {},
  updateAssetBuffer: () => {},
  clearAssetBuffer: () => {}
});

// 创建 Provider 组件
export function ProtocolProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<ProtocolState>(initialState);

  // 从localStorage加载初始状态
  useEffect(() => {
    try {
      const savedProtocol = localStorage.getItem('active_protocol');
      if (savedProtocol && savedProtocol.trim()) {
        const parsed = JSON.parse(savedProtocol);
        setState({
          activeProtocol: parsed.activeProtocol || null,
          assetBuffer: parsed.assetBuffer || null
        });
      }
    } catch (error) {
      console.error('Failed to load protocol from localStorage:', error);
      localStorage.removeItem('active_protocol');
    }
  }, []);

  // 当状态变化时，保存到localStorage
  useEffect(() => {
    try {
      localStorage.setItem('active_protocol', JSON.stringify(state));
    } catch (error) {
      console.error('Failed to save protocol to localStorage:', error);
    }
  }, [state]);

  // 设置活动协议
  const setActiveProtocol = (protocol: ActiveProtocol | null) => {
    setState(prev => ({
      ...prev,
      activeProtocol: protocol
    }));
  };

  // 更新协议
  const updateProtocol = (updates: Partial<ActiveProtocol>) => {
    if (state.activeProtocol) {
      setState(prev => ({
        ...prev,
        activeProtocol: {
          ...prev.activeProtocol,
          ...updates
        }
      }));
    }
  };

  // 清除协议
  const clearProtocol = () => {
    setState(prev => ({
      ...prev,
      activeProtocol: null
    }));
  };

  // 设置资产缓冲区
  const setAssetBuffer = (asset: AssetBuffer | null) => {
    setState(prev => ({
      ...prev,
      assetBuffer: asset
    }));
  };

  // 更新资产缓冲区
  const updateAssetBuffer = (updates: Partial<AssetBuffer>) => {
    if (state.assetBuffer) {
      setState(prev => ({
        ...prev,
        assetBuffer: {
          ...prev.assetBuffer,
          ...updates
        }
      }));
    }
  };

  // 清除资产缓冲区
  const clearAssetBuffer = () => {
    setState(prev => ({
      ...prev,
      assetBuffer: null
    }));
  };

  return (
    <ProtocolContext.Provider value={{ 
      state, 
      setActiveProtocol, 
      updateProtocol, 
      clearProtocol,
      setAssetBuffer,
      updateAssetBuffer,
      clearAssetBuffer
    }}>
      {children}
    </ProtocolContext.Provider>
  );
}

// 创建自定义 Hook
export function useProtocolContext() {
  return useContext(ProtocolContext);
}
```

### 分析
- **inputValues 持久化逻辑**：ActiveProtocolStore.tsx 中没有直接的 inputValues 持久化逻辑。inputValues 似乎是在 P4LabPage.tsx 中管理的本地状态，没有被存储到 localStorage。
- **inputType 切换时的状态重置逻辑**：ActiveProtocolStore.tsx 中没有针对 inputType 切换时的状态重置逻辑。当切换协议时，只会更新 activeProtocol 字段，但不会重置任何其他状态。

## 2. API 请求适配器分析

### 核心函数
```typescript
export const executeMissionAPI = async (missionData: string | Blob | ArrayBuffer, params: any, inputType: InputType) => {
  // 错误熔断机制：检查必要条件
  if (!missionData) {
    if (inputType === 'text') {
      throw new Error('[PHYSICAL_EMPTY] 发射器未检测到文字内容');
    }
    throw new Error('[PHYSICAL_BREAK] 素材未加载，发射器物理熔断');
  }
  
  // 从params或默认值获取provider
  const providerName = params.provider || 'SiliconFlow';
  
  // 从PROVIDER_REGISTRY中物理调取配置
  const providerConfig = PROVIDER_REGISTRY[providerName];
  
  // 错误熔断：检查provider是否存在
  if (!providerConfig) {
    throw new Error(`[PHYSICAL_BREAK] 服务商 ${providerName} 未在物理注册表中注册`);
  }
  
  // 错误熔断：检查API Key
  if (!providerConfig.masterKey) {
    throw new Error('[PHYSICAL_BREAK] API Key为空，发射器物理熔断');
  }
  
  // 根据inputType和模型获取对应的端点
  const endpointMap = {
    image: '/images/generations',
    audio: '/audio/speech', // 修正为 SiliconFlow 国内节点语音克隆地址
    video: '/videos/generations',
    text: '/text/generations'
  };
  
  // 特殊处理：如果是文本输入且模型是CosyVoice，则使用语音合成端点
  let endpoint = endpointMap[inputType as keyof typeof endpointMap] || endpointMap.image;
  if (inputType === 'text' && params.model_id?.includes('CosyVoice') || params.model?.includes('CosyVoice')) {
    endpoint = '/audio/speech';
  }
  const url = `${providerConfig.baseUrl}${endpoint}`;
  
  // 自动报关：转换Payload
  const payload = await transformPayload(missionData, inputType, params);
  
  // 错误熔断：检查Payload长度
  const payloadLength = JSON.stringify(payload).length;
  if (payloadLength === 0) {
    throw new Error('[PHYSICAL_BREAK] Payload长度为0，发射器物理熔断');
  }
  
  // 强制拦截：检查payload.input是否为空或只有空格
  if (!payload.input || payload.input.trim() === '') {
    throw new Error('[PHYSICAL_EMPTY] 请在中央输入框填入文字再运行。');
  }
  
  // 物理封包：使用注册表中的authHeader函数进行物理封包
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...providerConfig.authHeader(providerConfig.masterKey)
  };
  
  // 物理预检：在fetch之前，强制执行日志
  console.log('[P4_MANIFEST]', {
    url,
    headers: {
      'Content-Type': headers['Content-Type'],
      'Authorization': headers['Authorization'].replace(/Bearer (.{6}).+/, 'Bearer $1...') // 脱敏Key
    },
    body_keys: Object.keys(payload)
  });
  
  // 拦截请求包检查：输出完整请求体
  console.log('API Request Body:', payload);
  
  // 调用外部API，添加mode: 'cors'防拦截
  const response = await fetch(url, {
    method: 'POST',
    headers: headers,
    body: JSON.stringify(payload),
    mode: 'cors'
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error(`[API_RESPONSE] 调用失败: ${response.status} ${errorText}`);
    throw new Error(`API调用失败: ${response.status} ${response.statusText}`);
  }
  
  console.log(`[API_RESPONSE] 调用成功`);
  
  // 根据响应类型处理不同的返回格式
  // 检查是否为音频响应：1. 检查response.headers的Content-Type 2. 根据inputType和endpoint判断
  const contentType = response.headers.get('Content-Type') || '';
  const isAudioResponse = contentType.includes('audio/') || 
                        (inputType === 'audio' && endpoint === '/audio/speech') ||
                        (params.model_id?.includes('CosyVoice') || params.model?.includes('CosyVoice'));
  
  if (isAudioResponse) {
    // 音频响应：使用response.blob()获取数据
    try {
      // 获取二进制数据
      const blob = await response.blob();
      // 物理转换逻辑：将二进制数据转化为浏览器可播放的临时链接
      const objectUrl = URL.createObjectURL(blob);
      return objectUrl;
    } catch (error) {
      console.error('[AUDIO_PROCESS_ERROR] 处理音频响应失败:', error);
      throw new Error('处理音频响应失败');
    }
  } else {
    // 非音频响应：返回JSON数据
    try {
      return await response.json();
    } catch (error) {
      console.error('[JSON_PARSE_ERROR] 解析JSON响应失败:', error);
      throw new Error('解析JSON响应失败');
    }
  }
};
```

### 分析
- **处理 image 类型**：
  - 在 `transformPayload` 函数中，对于 `inputType === 'image'` 的情况，会将图片数据转换为 Base64 格式
  - 如果 `missionData` 是字符串且以 `data:image/` 开头，会去掉前缀得到纯净的 Base64
  - 如果 `missionData` 是 Blob 或 File 对象，会使用 FileReader 将其转换为 Base64
  - 最终将 Base64 数据存储在 `payload.image` 字段中

- **处理 audio 类型**：
  - 在 `transformPayload` 函数中，对于 `inputType === 'audio'` 的情况，会将音频数据作为字符串处理
  - 最终将音频数据存储在 `payload.input` 字段中
  - 注意：这里似乎只处理了文本形式的音频数据，对于二进制音频文件的处理逻辑不明确

- **请求方式**：
  - 所有请求都使用 `JSON.stringify(payload)` 将数据转换为 JSON 格式
  - 使用 `Content-Type: application/json` 作为请求头
  - 不使用 FormData 格式

## 3. UI 渲染契约验证

### 完整代码
```typescript
const renderDynamicUI = () => {
  // 获取当前协议，优先使用全局协议
  const currentProtocol = protocolState.activeProtocol;
  
  // 诚实的调试探针
  console.log('当前激活协议:', currentProtocol);
  if (!currentProtocol) {
    console.log('[P4报错] 协议未激活');
  }
  
  // 组装最终的UI
  const finalUI = [];
  
  // 只有在协议存在时才渲染参数配置
  if (currentProtocol) {
    const { params_schema } = currentProtocol;
    
    // 渲染所有参数UI
    const renderedParams = params_schema.map(param => {
      // 获取当前值
      const currentValue = inputValues[param.id] || param.defaultValue || (param.type === 'Boolean' ? false : 0);
      
      return (
        <div key={param.id} style={{ marginBottom: '24px', padding: '16px', backgroundColor: '#2d2d30', borderRadius: '8px', border: '1px solid #3e3e42' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
            <label style={{ fontSize: '14px', fontWeight: 500, color: '#cccccc', display: 'block' }}>
              {param.name} {param.required && <span style={{ color: '#ef4444' }}>*</span>}
            </label>
          </div>
          
          {/* 根据参数类型渲染不同的AntD组件，完善数据绑定 */}
          {param.type === 'slider' || param.type === 'Number' ? (
            <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
              <Slider
                min={param.min || 0}
                max={param.max || 100}
                step={param.step || 1}
                value={typeof currentValue === 'number' ? currentValue : 0}
                onChange={(val) => handleInputChange(param.id, val)}
                tooltip={{ formatter: (value) => `${value}` }}
                style={{ color: '#06b6d4' }}
              />
              <InputNumber
                min={param.min || 0}
                max={param.max || 100}
                step={param.step || 1}
                value={currentValue}
                onChange={(val) => handleInputChange(param.id, val)}
                style={{
                  width: '120px',
                  backgroundColor: '#1e1e1e',
                  color: '#d4d4d4',
                  border: '1px solid #3e3e42'
                }}
              />
            </div>
          ) : param.type === 'Boolean' ? (
            <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
              <Switch
                checked={Boolean(currentValue)}
                onChange={(checked) => handleInputChange(param.id, checked)}
                style={{
                  backgroundColor: Boolean(currentValue) ? '#06b6d4' : '#3e3e42'
                }}
              />
              <span style={{ color: '#9cdcfe' }}>{Boolean(currentValue) ? '开启' : '关闭'}</span>
            </div>
          ) : param.type === 'select' ? (
            <Select
              value={currentValue}
              onChange={(val) => handleInputChange(param.id, val)}
              style={{
                width: '100%',
                backgroundColor: '#1e1e1e',
                color: '#d4d4d4',
                border: '1px solid #3e3e42'
              }}
              options={param.options || []} // 确保协议里有 options
            />
          ) : param.type === 'color' ? (
            <ColorPicker
              value={currentValue}
              onChange={(color) => handleInputChange(param.id, color.toHexString())}
              style={{
                backgroundColor: '#1e1e1e',
                border: '1px solid #3e3e42'
              }}
            />
          ) : (
            <Input
              value={currentValue}
              onChange={(e) => handleInputChange(param.id, e.target.value)}
              placeholder={`请输入${param.name}`}
              style={{
                backgroundColor: '#1e1e1e',
                color: '#d4d4d4',
                border: '1px solid #3e3e42'
              }}
            />
          )}
        </div>
      );
    });
    
    // 添加参数配置区域
    if (renderedParams.length > 0) {
      finalUI.push(
        <div key="params-section" style={{ marginBottom: '24px' }}>
          <h3 style={{ color: '#06b6d4', marginBottom: '16px', fontSize: '16px', fontWeight: 'bold' }}>⚙️ 参数配置</h3>
          {renderedParams}
        </div>
      );
    }
  }
  
  return finalUI;
};
```

### 分析
- **支持的类型**：
  - `slider` / `Number`：渲染 Slider 和 InputNumber 组件
  - `Boolean`：渲染 Switch 组件
  - `select`：渲染 Select 组件，支持 options 属性
  - `color`：渲染 ColorPicker 组件
  - 其他类型：渲染 Input 组件

- **新类型处理**：
  - 如果协议中定义了新类型，renderDynamicUI 函数会将其视为默认类型，渲染 Input 组件
  - 不会因为新类型而崩溃，会有一个合理的默认处理

## 4. 环境与授权

### 环境文件
- 项目根目录下不存在 .env 文件模板

### API Key 注入方式
```typescript
// 登记供应商 (已保留硅基流动作为备案)
export const PROVIDER_REGISTRY: Record<string, ProviderConfig> = {
  SiliconFlow: {
    baseUrl: "https://api.siliconflow.cn/v1",
    masterKey: "sk-tpcfhwsckdrngcfeymudxjgnuhxadegbqzjztnakfceutvwy",
    authHeader: (key) => ({ Authorization: `Bearer ${key}` })
  },
  FishAudio: {
    baseUrl: "https://api.fish.audio/v1",
    masterKey: "你的_FISH_AUDIO_KEY_此处预留",
    authHeader: (key) => ({ Authorization: `Bearer ${key}` })
  },
  Gemini: {
    baseUrl: "https://generativelanguage.googleapis.com/v1",
    masterKey: "AIzaSyAQ6NygEXo0pdJXS7du57rPjUS0T4BBpVc",
    authHeader: (key) => ({ "x-goog-api-key": key })
  }
};
```

### 分析
- **API Key 存储方式**：SiliconFlow 的 API Key 直接硬编码在 `apiProviderConfig.ts` 文件中
- **注入方式**：在 `executeMissionAPI` 函数中，通过 `providerConfig.authHeader(providerConfig.masterKey)` 将 API Key 注入到请求头中
- **安全性**：API Key 以明文形式存储在代码中，没有使用环境变量或其他安全存储方式
