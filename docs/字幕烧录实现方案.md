# å­—å¹•çƒ§å½•å®ç°æ–¹æ¡ˆ

**åˆ›å»ºæ—¶é—´**: 2026-02-05
**ä¼˜å…ˆçº§**: P0 - å…³é”®åŠŸèƒ½
**çŠ¶æ€**: ğŸ“‹ å¾…åç«¯å®ç°

---

## éœ€æ±‚èƒŒæ™¯

å½“å‰è§†é¢‘ç”Ÿæˆåï¼Œå­—å¹•åªåœ¨Webæ’­æ”¾å™¨ä¸­æ˜¾ç¤ºï¼ˆWebVTTæ ¼å¼ï¼‰ï¼Œç”¨æˆ·ä¸‹è½½çš„è§†é¢‘æ–‡ä»¶ä¸åŒ…å«å­—å¹•ã€‚

**ç”¨æˆ·è¦æ±‚**ï¼šä¸‹è½½çš„è§†é¢‘å¿…é¡»åŒ…å«çƒ§å½•çš„å­—å¹•ï¼Œå¦åˆ™æ–¹æ¡ˆå¤±è´¥ã€‚

---

## æŠ€æœ¯æ–¹æ¡ˆ

### æ–¹æ¡ˆ1: åç«¯FFmpegçƒ§å½•ï¼ˆæ¨èï¼‰

#### 1.1 åç«¯APIè®¾è®¡

**APIç«¯ç‚¹**: `POST /api/video/burn-subtitle`

**è¯·æ±‚å‚æ•°**:
```json
{
  "video_url": "https://xxx.com/video.mp4",
  "text": "é©¬å¹´å¤§å‰ï¼Œæ­å–œå‘è´¢ï¼ç¥æ‚¨èº«ä½“å¥åº·ï¼Œä¸‡äº‹å¦‚æ„ï¼",
  "duration": 12.5,
  "style": {
    "font_size": 24,
    "font_color": "white",
    "bg_color": "rgba(0,0,0,0.7)",
    "position": "bottom",
    "padding": 10
  }
}
```

**å“åº”**:
```json
{
  "success": true,
  "video_url": "https://xxx.com/video_with_subtitle.mp4",
  "task_id": "task_xxx",
  "estimated_time": 15
}
```

#### 1.2 åç«¯å®ç°ï¼ˆPython + FFmpegï¼‰

```python
import ffmpeg
import os
import tempfile
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/api/video/burn-subtitle', methods=['POST'])
def burn_subtitle():
    data = request.json
    video_url = data['video_url']
    text = data['text']
    duration = data['duration']
    style = data.get('style', {})

    # ä¸‹è½½è§†é¢‘
    video_path = download_video(video_url)

    # ç”Ÿæˆå­—å¹•æ–‡ä»¶ï¼ˆSRTæ ¼å¼ï¼‰
    srt_path = generate_srt(text, duration)

    # FFmpegçƒ§å½•å­—å¹•
    output_path = tempfile.mktemp(suffix='.mp4')

    try:
        (
            ffmpeg
            .input(video_path)
            .output(
                output_path,
                vf=f"subtitles={srt_path}:force_style='FontSize={style.get('font_size', 24)},PrimaryColour=&Hffffff&,OutlineColour=&H000000&,BorderStyle=3,Outline=1,Shadow=0,MarginV=30'"
            )
            .overwrite_output()
            .run(capture_stdout=True, capture_stderr=True)
        )

        # ä¸Šä¼ åˆ°COS
        output_url = upload_to_cos(output_path)

        return jsonify({
            'success': True,
            'video_url': output_url
        })

    except ffmpeg.Error as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

    finally:
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        os.remove(video_path)
        os.remove(srt_path)
        if os.path.exists(output_path):
            os.remove(output_path)

def generate_srt(text, duration):
    """ç”ŸæˆSRTå­—å¹•æ–‡ä»¶"""
    srt_content = f"""1
00:00:00,000 --> 00:00:{int(duration):02d},{int((duration % 1) * 1000):03d}
{text}
"""

    srt_path = tempfile.mktemp(suffix='.srt')
    with open(srt_path, 'w', encoding='utf-8') as f:
        f.write(srt_content)

    return srt_path
```

#### 1.3 å‰ç«¯é›†æˆ

```typescript
// VideoPage.tsx ä¿®æ”¹ç”Ÿæˆè§†é¢‘é€»è¾‘

// æ­¥éª¤4: è°ƒç”¨WAN APIç”Ÿæˆè§†é¢‘
const wanResult = await sendRequest({...});

if (!wanResult.success || !wanResult.data?.video_url) {
  throw new Error('è§†é¢‘ç”Ÿæˆå¤±è´¥');
}

let finalVideoUrl = wanResult.data.video_url;

// æ­¥éª¤5: å¦‚æœæœ‰æ–‡æ¡ˆï¼Œè°ƒç”¨å­—å¹•çƒ§å½•API
if (text.trim()) {
  setProgress({ progress: 90, message: 'æ­£åœ¨æ·»åŠ å­—å¹•...' });

  const subtitleResult = await fetch('/api/video/burn-subtitle', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      video_url: finalVideoUrl,
      text: text.trim(),
      duration: estimateDuration(text.trim()),
      style: {
        font_size: 24,
        font_color: 'white',
        bg_color: 'rgba(0,0,0,0.7)',
        position: 'bottom'
      }
    })
  });

  const subtitleData = await subtitleResult.json();

  if (subtitleData.success) {
    finalVideoUrl = subtitleData.video_url;
    console.log('[VideoPage] å­—å¹•çƒ§å½•æˆåŠŸ');
  } else {
    console.warn('[VideoPage] å­—å¹•çƒ§å½•å¤±è´¥ï¼Œä½¿ç”¨åŸè§†é¢‘:', subtitleData.error);
  }
}

setWanVideoUrl(finalVideoUrl);
```

---

### æ–¹æ¡ˆ2: å‰ç«¯FFmpeg.wasmçƒ§å½•ï¼ˆå¤‡é€‰ï¼‰

#### 2.1 ä¼˜ç‚¹
- æ— éœ€åç«¯æ”¯æŒ
- å³æ—¶å¯ç”¨

#### 2.2 ç¼ºç‚¹
- æ€§èƒ½è¾ƒå·®ï¼ˆè§†é¢‘å¤„ç†æ—¶é—´é•¿ï¼‰
- éœ€è¦ä¸‹è½½FFmpeg.wasmï¼ˆ~25MBï¼‰
- å¯èƒ½å¯¼è‡´æµè§ˆå™¨å¡é¡¿

#### 2.3 å®ç°ä»£ç 

```typescript
import { createFFmpeg, fetchFile } from '@ffmpeg/ffmpeg';

const ffmpeg = createFFmpeg({ log: true });

async function burnSubtitle(videoUrl: string, text: string): Promise<string> {
  // åŠ è½½FFmpeg
  if (!ffmpeg.isLoaded()) {
    await ffmpeg.load();
  }

  // ä¸‹è½½è§†é¢‘
  ffmpeg.FS('writeFile', 'input.mp4', await fetchFile(videoUrl));

  // ç”Ÿæˆå­—å¹•æ–‡ä»¶
  const srt = `1\n00:00:00,000 --> 00:00:15,000\n${text}\n`;
  ffmpeg.FS('writeFile', 'subtitle.srt', new TextEncoder().encode(srt));

  // çƒ§å½•å­—å¹•
  await ffmpeg.run(
    '-i', 'input.mp4',
    '-vf', "subtitles=subtitle.srt:force_style='FontSize=24,PrimaryColour=&Hffffff&'",
    'output.mp4'
  );

  // è¯»å–è¾“å‡º
  const data = ffmpeg.FS('readFile', 'output.mp4');

  // åˆ›å»ºBlob URL
  const blob = new Blob([data.buffer], { type: 'video/mp4' });
  return URL.createObjectURL(blob);
}
```

---

## å®æ–½è®¡åˆ’

### é˜¶æ®µ1: åç«¯APIå¼€å‘ï¼ˆä¼˜å…ˆï¼‰
- [ ] æ­å»ºPython FlaskæœåŠ¡
- [ ] é›†æˆFFmpegåº“
- [ ] å®ç°å­—å¹•çƒ§å½•API
- [ ] éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
- [ ] é…ç½®COSä¸Šä¼ 

### é˜¶æ®µ2: å‰ç«¯é›†æˆ
- [ ] ä¿®æ”¹VideoPageç”Ÿæˆé€»è¾‘
- [ ] è°ƒç”¨å­—å¹•çƒ§å½•API
- [ ] æ·»åŠ é”™è¯¯å¤„ç†å’Œé™çº§æ–¹æ¡ˆ
- [ ] æµ‹è¯•å®Œæ•´æµç¨‹

### é˜¶æ®µ3: ä¼˜åŒ–ï¼ˆå¯é€‰ï¼‰
- [ ] æ”¯æŒè‡ªå®šä¹‰å­—å¹•æ ·å¼
- [ ] æ”¯æŒå¤šè¡Œå­—å¹•
- [ ] æ”¯æŒå­—å¹•æ—¶é—´è½´ï¼ˆè¯­éŸ³è¯†åˆ«ï¼‰
- [ ] æ‰¹é‡å¤„ç†

---

## å½“å‰çŠ¶æ€

**ä¸´æ—¶æ–¹æ¡ˆ**: ä¿ç•™å‰ç«¯WebVTTå­—å¹•ï¼Œåœ¨æ’­æ”¾å™¨ä¸­æ˜¾ç¤ºã€‚

**å¾…å®ç°**: åç«¯FFmpegå­—å¹•çƒ§å½•APIã€‚

**é£é™©**: å¦‚æœåç«¯APIæœªåŠæ—¶å®ç°ï¼Œç”¨æˆ·ä¸‹è½½çš„è§†é¢‘å°†ä¸åŒ…å«å­—å¹•ã€‚

---

## å¼€å‘èµ„æº

**FFmpegå®˜æ–¹æ–‡æ¡£**: https://ffmpeg.org/ffmpeg-filters.html#subtitles
**Python FFmpegåº“**: https://github.com/kkroening/ffmpeg-python
**FFmpeg.wasm**: https://github.com/ffmpegwasm/ffmpeg.wasm

---

**å¤‡æ³¨**: å¼ºçƒˆå»ºè®®ä¼˜å…ˆå®ç°æ–¹æ¡ˆ1ï¼ˆåç«¯FFmpegçƒ§å½•ï¼‰ï¼Œå› ä¸ºç”¨æˆ·æ˜ç¡®è¦æ±‚ä¸‹è½½çš„è§†é¢‘å¿…é¡»åŒ…å«å­—å¹•ã€‚
