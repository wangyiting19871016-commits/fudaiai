# 🎯 正确的素材融合技术方案

## 用户真实需求（已理解）

### 现有流程：
1. 用户上传人脸照片
2. M2换脸 + **完整场景模板**（如：女生+红色西装+橙色背景+灯笼装饰）
3. 生成结果：**完整的带背景图片**（1024x1024 JPG/PNG）

### 用户想要：
在这个**已有背景的完整图片**上，再叠加：
- 📜 对联（左右两侧）
- 🎨 装饰（印章、烫金字、书法）
- ✍️ 文字（祝福语、姓名）

---

## ❌ 之前理解错误

我之前以为：
- 换脸模板是透明背景人物
- 需要替换背景
- **完全错了！**

---

## ✅ 正确技术方案

### 核心原理：**在完整图片上叠加装饰层**

```
完整换脸结果图（已有背景）
         ↓
    Canvas画布加载
         ↓
    叠加对联层（PNG透明，放在左右两侧空白处）
         ↓
    叠加装饰层（印章、艺术字，放在合适位置）
         ↓
    叠加文字层（祝福语）
         ↓
    导出最终图片
```

---

## 技术实现细节

### 1. 初始化Canvas（加载换脸结果）

```typescript
// 用户点击"编辑装饰"按钮
const canvas = new fabric.Canvas('editor-canvas', {
  width: 1024,
  height: 1024
});

// 加载M2换脸结果图（完整图片，有背景）
fabric.Image.fromURL(faceSwapResultUrl, (img) => {
  img.set({
    selectable: false,  // 锁定底图，不可删除
    evented: false
  });
  canvas.add(img);
  canvas.sendToBack(img);  // 底图在最下层
  canvas.renderAll();
});
```

---

### 2. 添加对联（关键：智能定位）

#### 问题：对联放哪里？
- ❌ 不能遮挡人脸
- ❌ 不能遮挡重要装饰（已有的红包、灯笼等）
- ✅ 放在**左右两侧空白区域**
- ✅ 或者**顶部/底部空白区域**

#### 方案A：固定位置（简单）

```typescript
// 对联PNG图片（透明背景，竖版长条）
const coupletConfig = {
  upper: {  // 上联（右侧）
    url: '/assets/couplets/fortune_001_upper.png',
    position: { left: 900, top: 100 },  // 右侧
    scale: 0.3
  },
  lower: {  // 下联（左侧）
    url: '/assets/couplets/fortune_001_lower.png',
    position: { left: 50, top: 100 },   // 左侧
    scale: 0.3
  },
  horizontal: {  // 横批（顶部）
    url: '/assets/couplets/fortune_001_horizontal.png',
    position: { left: 250, top: 30 },
    scale: 0.3
  }
};

// 添加对联
function addCouplet(canvas, coupletConfig) {
  // 上联
  fabric.Image.fromURL(coupletConfig.upper.url, (img) => {
    img.set({
      ...coupletConfig.upper.position,
      scaleX: coupletConfig.upper.scale,
      scaleY: coupletConfig.upper.scale,
      selectable: true,  // 用户可以手动调整位置
      hasControls: true
    });
    canvas.add(img);
    canvas.renderAll();
  });

  // 下联、横批同理...
}
```

#### 方案B：智能定位（高级）

```typescript
// 使用人脸检测API，避开人脸区域
async function getSmartCoupletPosition(imageUrl) {
  // 调用人脸检测（可选：face-api.js / OpenCV）
  const faceBox = await detectFace(imageUrl);

  // 计算安全区域
  const safeZones = {
    leftSide: {
      x: 0,
      y: 0,
      width: Math.min(100, faceBox.left - 50),
      height: 1024
    },
    rightSide: {
      x: Math.max(924, faceBox.right + 50),
      y: 0,
      width: 100,
      height: 1024
    }
  };

  return {
    upper: { left: safeZones.rightSide.x, top: 100 },
    lower: { left: safeZones.leftSide.x + 20, top: 100 }
  };
}
```

---

### 3. 添加装饰（印章、艺术字）

#### 关键：混合模式 + 透明度

```typescript
function addDecoration(canvas, decorationUrl) {
  fabric.Image.fromURL(decorationUrl, (img) => {
    img.set({
      left: 100,
      top: 100,
      scaleX: 0.3,
      scaleY: 0.3,
      opacity: 0.9,  // 90%透明度，更自然融合
      globalCompositeOperation: 'multiply',  // 混合模式：正片叠底
      selectable: true
    });
    canvas.add(img);
    canvas.renderAll();
  });
}
```

#### 混合模式选项：
- `'multiply'` - 正片叠底（印章效果）
- `'overlay'` - 叠加（烫金效果）
- `'screen'` - 滤色（光效）
- `'normal'` - 正常（默认）

---

### 4. 添加文字（祝福语）

```typescript
function addText(canvas, text) {
  const textObj = new fabric.Text(text, {
    left: 100,
    top: 100,
    fontSize: 48,
    fontFamily: 'SimSun',  // 宋体
    fill: '#DC143C',       // 深红色
    stroke: '#FFD700',     // 金色描边
    strokeWidth: 2,
    shadow: 'rgba(0,0,0,0.3) 2px 2px 4px',  // 阴影
    selectable: true,
    editable: true
  });
  canvas.add(textObj);
  canvas.renderAll();
}
```

---

### 5. 导出最终图片

```typescript
function exportImage(canvas) {
  const dataURL = canvas.toDataURL({
    format: 'png',
    quality: 1.0,
    multiplier: 2  // 2倍分辨率（2048x2048）
  });

  return dataURL;
}
```

---

## 对联制作方案

### 方案1：PNG透明对联（推荐）

**制作方式**：
1. PS/Canvas生成竖版对联PNG（200x1000px）
2. 透明背景
3. 红色文字 + 金色描边

**优点**：
- 加载快
- 样式统一
- 可预览

**脚本**：
```bash
node scripts/generateCoupletPNG.js
# 自动生成30张对联PNG
```

---

### 方案2：动态文字渲染

**实现方式**：
```typescript
function renderCoupletText(canvas, text, position) {
  const chars = text.split('');
  const spacing = 60;

  chars.forEach((char, i) => {
    const textObj = new fabric.Text(char, {
      left: position.left,
      top: position.top + i * spacing,
      fontSize: 48,
      fontFamily: 'KaiTi',  // 楷体
      fill: '#8B0000',
      stroke: '#FFD700',
      strokeWidth: 3
    });
    canvas.add(textObj);
  });
}
```

**优点**：
- 灵活，用户可自定义对联内容
- 无需预制PNG

**缺点**：
- 需要加载字体文件
- 性能略低

---

## 关键问题解答

### Q1: 对联会不会遮挡人脸？
**A1**: 三种解决方案：
1. **固定位置** - 放在左右两侧固定位置（X < 100 或 X > 900）
2. **用户手动调整** - 对联可拖拽，用户自己调整位置
3. **智能检测** - 使用人脸检测API，自动避开人脸区域

---

### Q2: 对联PNG如何制作？
**A2**:
- **脚本自动生成**：`node scripts/generateCoupletPNG.js`
- **PS手工制作**：新建200x1000px画布，透明背景，输入文字，导出PNG
- **设计师外包**：猪八戒/Fiverr（约¥50/组）

---

### Q3: 装饰如何自然融合？
**A3**: 使用混合模式 + 透明度：
```typescript
img.set({
  opacity: 0.85,  // 85%透明度
  globalCompositeOperation: 'multiply'  // 正片叠底
});
```

---

### Q4: 如果模板本身很满，没空间加对联怎么办？
**A4**: 三种方案：
1. **缩小对联** - 缩放到0.2-0.3倍
2. **半透明叠加** - 对联透明度50%，不完全遮挡
3. **顶部/底部横批** - 只加横批，不加竖联

---

## 实际案例演示

### 案例1：女性新年照（橙色背景+灯笼）

**原图**：换脸结果（完整场景）
**操作**：
1. 加载结果图到Canvas
2. 在左侧（X=50）添加下联PNG
3. 在右侧（X=900）添加上联PNG
4. 在顶部（Y=30）添加横批PNG
5. 在左下角（X=80, Y=900）添加印章PNG
6. 在底部中央（X=512, Y=980）添加文字"恭喜发财"

**效果**：
- 对联不遮挡人脸 ✅
- 装饰协调融合 ✅
- 整体喜庆美观 ✅

---

### 案例2：男性创意照（黑色背景+龙头装饰）

**原图**：换脸结果（已有"喜春"文字+龙头装饰）
**操作**：
1. 加载结果图
2. 只在四个角落添加小装饰（烫金元素）
3. 底部添加艺术字"新春快乐"
4. **不添加对联**（因为画面已经很满）

**效果**：
- 画龙点睛 ✅
- 不抢镜 ✅

---

## 技术优势

✅ **无需抠图** - 直接在完整图上叠加，简单快速
✅ **灵活可调** - 用户可拖拽调整所有装饰位置
✅ **多种融合模式** - 支持混合模式，自然融合
✅ **高清导出** - 支持2倍分辨率导出（2048x2048）
✅ **撤销重做** - 支持历史记录，随时回退

---

## 代码已实现

- ✅ `src/components/ImageComposerEditor.tsx` - 图片编辑器（基于Fabric.js）
- ✅ Canvas图层管理
- ✅ 撤销/重做功能
- ✅ 导出PNG功能

**只需**：
1. 生成对联PNG（运行脚本）
2. 在ResultPage添加"编辑装饰"按钮
3. 集成ImageComposerEditor组件

---

## 下一步行动

### 立即可做：
1. ✅ **生成对联PNG**（10分钟）
   ```bash
   npm install canvas
   node scripts/generateCoupletPNG.js
   ```

2. ✅ **统计新买的模板数量**（5分钟）
   - 男性模板：多少张？
   - 女性模板：多少张？
   - 背景类型：现代风/传统风/创意风？

3. ✅ **集成编辑器到ResultPage**（30分钟）
   - 添加"编辑装饰"按钮
   - 打开ImageComposerEditor
   - 保存编辑结果

---

## 总结

**核心技术**：Canvas叠加层
**输入**：M2换脸结果图（完整图片，已有背景）
**处理**：叠加对联、装饰、文字
**输出**：最终合成图片（2048x2048 PNG）

**完全可行！技术成熟！** ✅
